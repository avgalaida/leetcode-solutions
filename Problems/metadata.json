[
  {
    "title": "1. Two Sum",
    "difficulty": "easy",
    "tags": ["hash map", "array"],
    "description": "Найти два числа, сумма которых равна целевому значению.",
    "leetcode_url": "https://leetcode.com/problems/two-sum/",
    "solutions": [
      {
        "description": "Решение с использованием хеш-таблицы (сложность O(n))",
        "file": "1. Two Sum.cs"
      }
    ]
  },
  {
    "title": "20. Valid Parentheses",
    "difficulty": "easy",
    "tags": ["stack", "string"],
    "description": "Проверить, является ли строка валидной, если она состоит только из символов '(', ')', '{', '}', '[' и ']'. Строка валидна, если каждая открывающая скобка имеет соответствующую закрывающую и скобки правильно вложены.",
    "leetcode_url": "https://leetcode.com/problems/valid-parentheses/",
    "solutions": [
      {
        "description": "Решение с использованием стека для проверки парности скобок (сложность O(n))",
        "file": "20. Valid Parentheses.cs"
      }
    ]
  },
  {
    "title": "121. Best Time to Buy and Sell Stock",
    "difficulty": "easy",
    "tags": ["array", "dynamic programming"],
    "description": "Найти максимальную прибыль от одной транзакции покупки и продажи акций. В каждый день можно либо купить одну акцию, либо продать, либо ничего не делать.",
    "leetcode_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
    "solutions": [
      {
        "description": "Решение с использованием итерации по массиву цен и нахождения минимальной цены и максимальной прибыли (сложность O(n))",
        "file": "121. Best Time to Buy and Sell Stock.cs"
      }
    ]
  },
  {
    "title": "21. Merge Two Sorted Lists",
    "difficulty": "easy",
    "tags": ["linked list"],
    "description": "Объединить два отсортированных связанных списка в один отсортированный список.",
    "leetcode_url": "https://leetcode.com/problems/merge-two-sorted-lists/",
    "solutions": [
      {
        "description": "Итеративное решение с использованием указателей для объединения двух списков (сложность O(n+m))",
        "file": "21. Merge Two Sorted Lists.cs"
      }
    ]
  },
  {
    "title": "226. Invert Binary Tree",
    "difficulty": "easy",
    "tags": ["tree", "depth-first search", "breadth-first search"],
    "description": "Инвертировать бинарное дерево, поменяв местами левые и правые дочерние узлы.",
    "leetcode_url": "https://leetcode.com/problems/invert-binary-tree/",
    "solutions": [
      {
        "description": "Итеративное решение с использованием стека для обхода дерева в глубину и инверсии дочерних узлов (сложность O(n))",
        "file": "226. Invert Binary Tree.cs"
      }
    ]
  },
  {
    "title": "125. Valid Palindrome",
    "difficulty": "easy",
    "tags": ["two pointers", "string"],
    "description": "Проверить, является ли строка палиндромом, игнорируя пробелы, знаки препинания и регистр символов.",
    "leetcode_url": "https://leetcode.com/problems/valid-palindrome/",
    "solutions": [
      {
        "description": "Использование двух указателей для сравнения символов строки с игнорированием не буквенно-цифровых символов (сложность O(n))",
        "file": "125. Valid Palindrome.cs"
      }
    ]
  },
  {
    "title": "242. Valid Anagram",
    "difficulty": "easy",
    "tags": ["hash table", "string", "sorting"],
    "description": "Проверить, являются ли две строки анаграммами. Строки являются анаграммами, если они содержат одинаковые символы в одинаковом количестве.",
    "leetcode_url": "https://leetcode.com/problems/valid-anagram/",
    "solutions": [
      {
        "description": "Использование хэш-таблицы для подсчета количества символов в каждой строке (сложность O(n))",
        "file": "242. Valid Anagram.cs"
      }
    ]
  },
  {
    "title": "704. Binary Search",
    "difficulty": "easy",
    "tags": ["array", "binary search"],
    "description": "Найти индекс целевого значения в отсортированном массиве с использованием бинарного поиска. Если значение не найдено, вернуть -1.",
    "leetcode_url": "https://leetcode.com/problems/binary-search/",
    "solutions": [
      {
        "description": "Реализация бинарного поиска с использованием цикла для поиска целевого значения (сложность O(log n))",
        "file": "704. Binary Search.cs"
      }
    ]
  },
  {
    "title": "733. Flood Fill",
    "difficulty": "easy",
    "tags": ["array", "depth-first search", "breadth-first search"],
    "description": "Залить область изображения цветом, начиная с заданного пикселя, изменив все соседние пиксели того же цвета на новый цвет.",
    "leetcode_url": "https://leetcode.com/problems/flood-fill/",
    "solutions": [
      {
        "description": "Итеративное решение с использованием стека для обхода в глубину и замены цветов (сложность O(m * n))",
        "file": "733. Flood Fill.cs"
      }
    ]
  },
  {
    "title": "141. Linked List Cycle",
    "difficulty": "easy",
    "tags": ["linked list", "two pointers"],
    "description": "Проверить, содержит ли связный список цикл. Если цикл существует, вернуть true, иначе — false.",
    "leetcode_url": "https://leetcode.com/problems/linked-list-cycle/",
    "solutions": [
      {
        "description": "Использование алгоритма двух указателей (черепаха и заяц), чтобы определить наличие цикла за линейное время и с константной памятью (сложность O(n), память O(1)).",
        "file": "141. Linked List Cycle.cs"
      }
    ]
  },
  {
    "title": "232. Implement Queue using Stacks",
    "difficulty": "easy",
    "tags": ["stack", "design", "queue"],
    "description": "Реализовать очередь с помощью двух стеков, поддерживая операции добавления, удаления, просмотра элемента и проверки пустоты очереди.",
    "leetcode_url": "https://leetcode.com/problems/implement-queue-using-stacks/",
    "solutions": [
      {
        "description": "Реализация очереди с использованием двух стеков, где операции pop и peek оптимизированы для минимального перемещения элементов (сложность O(1) амортизированная).",
        "file": "232. Implement Queue using Stacks.cs"
      }
    ]
  },
  {
    "title": "169. Majority Element",
    "difficulty": "easy",
    "tags": ["array", "divide and conquer", "Boyer-Moore Voting Algorithm"],
    "description": "Найти элемент, который встречается в массиве более чем ⌊n / 2⌋ раз, где n — размер массива. Гарантируется, что такой элемент существует.",
    "leetcode_url": "https://leetcode.com/problems/majority-element/",
    "solutions": [
      {
        "description": "Решение с использованием алгоритма Бойера-Мура для нахождения элемента большинства с линейной временной сложностью и O(1) памяти.",
        "file": "169. Majority Element.cs"
      }
    ]
  },
  {
    "title": "67. Add Binary",
    "difficulty": "easy",
    "tags": ["math", "string", "bit manipulation"],
    "description": "Сложить две двоичные строки и вернуть результат в виде двоичной строки.",
    "leetcode_url": "https://leetcode.com/problems/add-binary/",
    "solutions": [
      {
        "description": "Использование цикла для сложения строк побитово с учетом переноса (сложность O(max(n, m)))",
        "file": "67. Add Binary.cs"
      }
    ]
  },
  {
    "title": "278. First Bad Version",
    "difficulty": "easy",
    "tags": ["binary search", "interactive"],
    "description": "Определить первую плохую версию из n версий, используя API IsBadVersion. Гарантируется, что плохая версия существует.",
    "leetcode_url": "https://leetcode.com/problems/first-bad-version/",
    "solutions": [
      {
        "description": "Реализация бинарного поиска для нахождения первой плохой версии, минимизирующая количество вызовов API (сложность O(log n)).",
        "file": "278. First Bad Version.cs"
      }
    ]
  },
  {
    "title": "383. Ransom Note",
    "difficulty": "easy",
    "tags": ["array", "string"],
    "description": "Проверить, можно ли создать строку ransomNote, используя символы строки magazine, где каждая буква из magazine может быть использована только один раз.",
    "leetcode_url": "https://leetcode.com/problems/ransom-note/",
    "solutions": [
      {
        "description": "Решение с использованием массива фиксированной длины (26 элементов) для подсчета символов, позволяет эффективно проверить наличие необходимых букв в magazine для составления ransomNote (сложность O(n + m)).",
        "file": "383. Ransom Note.cs"
      }
    ]
  },
  {
    "title": "70. Climbing Stairs",
    "difficulty": "easy",
    "tags": ["dynamic programming", "math"],
    "description": "Найти количество уникальных способов достичь вершины лестницы с n ступенями, при условии, что за один шаг можно подниматься на одну или две ступени.",
    "leetcode_url": "https://leetcode.com/problems/climbing-stairs/",
    "solutions": [
      {
        "description": "Оптимизированное решение с динамическим программированием, использующее два переменных для хранения предыдущих результатов, что сокращает использование памяти (сложность O(n)).",
        "file": "70. Climbing Stairs.cs"
      }
    ]
  },
  {
    "title": "409. Longest Palindrome",
    "difficulty": "easy",
    "tags": ["hash table", "string"],
    "description": "Найти длину самой длинной строки-палиндрома, которую можно составить из символов строки s. Палиндром может содержать максимум один символ с нечетной частотой.",
    "leetcode_url": "https://leetcode.com/problems/longest-palindrome/",
    "solutions": [
      {
        "description": "Использование хэш-таблицы для подсчета частоты символов, затем построение наибольшей палиндромной длины, с учётом символов с чётной и нечётной частотой (сложность O(n)).",
        "file": "409. Longest Palindrome.cs"
      }
    ]
  }
]